---
title: "Proposed API for tech.ml.dataset"
author: GenerateMe
date: "`r Sys.Date()`"
output:
    html_document:
        highlight: pygments
        theme: sandstone
        includes:
            in_header: better_tables.html
    pdf_document:
        highlight: tango
    md_document:
        variant: markdown_github
---


```{css echo=FALSE}
table { width: auto !important; margin-right: auto; margin-left: 2%; }
```


```{r setup, include=FALSE}
find_nrepl_port_up <- function() {
    wd <- getwd()
    while(wd != dirname(wd)) {
        f <- paste0(wd,"/.nrepl-port")
        if(file.exists(f)) return(paste0("@",f))
        wd <- dirname(wd)
        f <- NULL
    }
}
port_file <- find_nrepl_port_up()
if(is.null(port_file)) stop("nREPL port not found")
library(knitr)
knitr_one_string <- knitr:::one_string
nrepl_cmd  <- "rep"
opts_chunk$set(comment=NA, highlight=TRUE)
knit_engines$set(clojure = function(options) {
    rep_params <- if(isTRUE(options$stdout_only)) {
                      "--print 'out,1,%{out}' --print 'value,1,' -p"
                  } else {
                      "-p"
                  }
    code <- paste(rep_params, port_file, shQuote(knitr_one_string(options$code)))
    out <- if (options$eval) {
               if (options$message) message('running: ', nrepl_cmd, ' ', code)
               tryCatch(
                   system2(nrepl_cmd, code, stdout = TRUE, stderr = TRUE, env = options$engine.env),
                   error = function(e) {
                       if (!options$error) stop(e)
                       paste('Error in running command', nrepl_cmd)
                   }
               )
           } else ''
    if (!options$error && !is.null(attr(out, 'status'))) stop(knitr_one_string(out))
    engine_output(options, options$code, out)})
```

## Introduction

[tech.ml.dataset](https://github.com/techascent/tech.ml.dataset) is a great and fast library which brings columnar dataset to the Clojure. Chris Nuernberger has been working on this library for last year as a part of bigger `tech.ml` stack.

I've started to test the library and help to fix uncovered bugs. My main goal was to compare functionalities with the other standards from other platforms. I focused on R solutions: [dplyr](https://dplyr.tidyverse.org/), [tidyr](https://tidyr.tidyverse.org/) and [data.table](https://rdatatable.gitlab.io/data.table/).

During conversions of the examples I've come up how to reorganized existing `tech.ml.dataset` functions into simple to use API. The main goals were:

* Focus on dataset manipulation functionality, leaving other parts of `tech.ml` like pipelines, datatypes, readers, ML, etc.
* Single entry point for common operations - one function dispatching on given arguments.
* `group-by` results with special kind of dataset - a dataset containing subsets created after grouping as a column.
* Most operations recognize regular dataset and grouped dataset and process data accordingly.
* One function form to enable thread-first on dataset.

All proposed functions are grouped in tabs below. Select group to see examples and details.

INFO: The future of this API is not known yet. Two directions are possible: integration into `tech.ml` or development under `Scicloj` organization. For the time being use this repo if you want to try. Join the discussion on [Zulip](https://clojurians.zulipchat.com/#narrow/stream/236259-tech.2Eml.2Edataset.2Edev/topic/api)


Let's require main namespace and define dataset used in most examples:

```{clojure results="hide"}
(require '[techtest.api :as api])
(def DS (api/dataset {:V1 (take 9 (cycle [1 2]))
                      :V2 (range 1 10)
                      :V3 (take 9 (cycle [0.5 1.0 1.5]))
                      :V4 (take 9 (cycle [\A \B \C]))}))
```

```{clojure results="asis"}
DS
```


## Functionality {.tabset .tabset-fade}

### Dataset

Dataset is a special type which can be considered as a map of columns implemented around `tech.ml.datatype` library. Each column can be considered as named sequence of typed data. Supported types include integers, floats, string, boolean, date/time, objects etc.

#### Dataset creation 

Dataset can be created from various of types of Clojure structures and files:

* single values
* sequence of maps
* map of sequences or values
* sequence of columns (taken from other dataset or created manually)
* sequence of pairs
* file types: raw/gzipped csv/tsv, json, xls(x) taken from local file system or URL
* input stream

`api/dataset` accepts:

* data
* options (see documentation of `tech.ml.dataset/->dataset` function for full list):
- `:dataset-name` - name of the dataset
- `:num-rows` - number of rows to read from file
- `:header-row?` - indication if first row in file is a header
- `:key-fn` - function applied to column names (eg. `keyword`, to convert column names to keywords)
- `:separator` - column separator
- `:single-value-column-name` - name of the column when single value is provided

---

Empty dataset.

```{clojure}
(api/dataset)
```

---

Dataset from single value.

```{clojure results="asis"}
(api/dataset 999)
```

---

Set column name for single value. Also set the dataset name.

```{clojure results="asis"}
(api/dataset 999 {:single-value-column-name "my-single-value"})
(api/dataset 999 {:single-value-column-name ""
                  :dataset-name "Single value"})
```

---

Sequence of pairs (first = column name, second = value(s)).

```{clojure results="asis"}
(api/dataset [[:A 33] [:B 5] [:C :a]])
```

---

Not sequential values are repeated row-count number of times.

```{clojure results="asis"}
(api/dataset [[:A [1 2 3 4 5 6]] [:B "X"] [:C :a]])
```

---

Dataset created from map (keys = column name, second = value(s)). Works the same as sequence of pairs.

```{clojure results="asis"}
(api/dataset {:A 33})
(api/dataset {:A [1 2 3]})
(api/dataset {:A [3 4 5] :B "X"})
```

---

You can put any value inside a column

```{clojure results="asis"}
(api/dataset {:A [[3 4 5] [:a :b]] :B "X"})
```

---

Sequence of maps

```{clojure results="asis"}
(api/dataset [{:a 1 :b 3} {:b 2 :a 99}])
(api/dataset [{:a 1 :b [1 2 3]} {:a 2 :b [3 4]}])
```

---

Missing values are marked by `nil`

```{clojure results="asis"}
(api/dataset [{:a nil :b 1} {:a 3 :b 4} {:a 11}])
```

---

Import CSV file

```{clojure results="asis"}
(api/dataset "data/family.csv")
```

---

Import from URL

```{clojure results="hide"}
(defonce ds (api/dataset "https://vega.github.io/vega-lite/examples/data/seattle-weather.csv"))
```

```{clojure results="asis"}
ds
```

#### Saving

Export dataset to a file or output stream can be done by calling `api/write-csv!`. Function accepts:

* dataset
* file name with one of the extensions: `.csv`, `.tsv`, `.csv.gz` and `.tsv.gz` or output stream
* options:
- `:separator` - string or separator char.

```{clojure}
(api/write-csv! ds "output.tsv.gz")
(.exists (clojure.java.io/file "output.csv.gz"))
```

#### Dataset related functions

Summary functions about the dataset like number of rows, columns and basic stats.

---

Number of rows

```{clojure}
(api/row-count ds)
```

---

Number of columns

```{clojure}
(api/column-count ds)
```

---

Names of columns.

```{clojure}
(api/column-names ds)
```

---

Shape of the dataset, [row count, column count]

```{clojure}
(api/shape ds)
```

---

General info about dataset. There are three variants:

* default - containing information about columns with basic statistics
* `:basic` - just name, row and column count and information if dataset is a result of `group-by` operation
* `:columns` - columns' metadata

```{clojure results="asis"}
(api/info ds)
(api/info ds :basic)
(api/info ds :columns)
```

---

Getting a dataset name

```{clojure}
(api/dataset-name ds)
```

---

Setting a dataset name (operation is immutable).

```{clojure}
(->> "seattle-weather"
     (api/set-dataset-name ds)
     (api/dataset-name))
```

#### Columns and rows

Get columns and rows as sequences. `column`, `columns` and `rows` treat grouped dataset as regular one. See `Groups` to read more about grouped datasets. 

---

Select column.

```{clojure}
(ds "wind")
(api/column ds "date")
```

---

Columns as sequence

```{clojure}
(take 2 (api/columns ds))
```

---

Columns as map

```{clojure}
(keys (api/columns ds :as-map))
```

---

Rows as sequence of sequences

```{clojure}
(take 2 (api/rows ds))
```

---

Rows as sequence of maps

```{clojure stdout_only=TRUE}
(clojure.pprint/pprint (take 2 (api/rows ds :as-maps)))
```

### Group-by

Grouping by is an operation which splits dataset into subdatasets and pack it into new special type of... dataset. I distinguish two types of dataset: regular dataset and grouped dataset. The latter is the result of grouping.

Grouped dataset is annotated in by `:grouped?` meta tag and consist following columns:

* `:name` - group name or structure
* `:group-id` - integer assigned to the group
* `:count` - number of elements in a group
* `:data` - groups as datasets

Almost all functions recognize type of the dataset (grouped or not) and operate accordingly. 

You can't apply reshaping or join/concat functions on grouped datasets.

#### Grouping

Grouping is done by calling `group-by` function with arguments:

* `ds` - dataset
* `grouping-selector` - what to use for grouping
* options:
    - `:result-type` - what to return:
        * `:as-dataset` (default) - return grouped dataset
        * `:as-indexes` - return rows ids (row number from original dataset)
        * `:as-map` - return map with group names as keys and subdataset as values
        * `:as-seq` - return sequens of subdatasets
    - `:limit-columns` - list of the columns which should be returned during grouping by function.

All subdatasets (groups) have set name as the group name, additionally `group-id` is in meta.

Grouping can be done by:

* single column name
* seq of column names
* map of keys (group names) and row indexes
* value returned by function taking row as map

Note: currently dataset inside dataset is printed recursively so it renders poorly from markdown. So I will use `:as-seq` result type to show just group names and groups.

---

List of columns in groupd dataset

```{clojure}
(api/column-names (api/group-by DS :V1))
```

---

Content of the grouped dataset

```{clojure}
(api/columns (api/group-by DS :V1) :as-map)
```

---

Grouped dataset as map

```{clojure}
(keys (api/group-by DS :V1 {:result-type :as-map}))
```

```{clojure results="asis"}
(vals (api/group-by DS :V1 {:result-type :as-map}))
```

---

Group dataset as map of indexes (row ids)

```{clojure}
(api/group-by DS :V1 {:result-type :as-indexes})
```

---

To get groups as sequence or a map can be done from grouped dataset using `groups->seq` and `groups->map` functions.

Groups as seq can be obtained by just accessing `:data` column.

I will use temporary dataset here.

```{clojure results="asis"}
(let [ds (-> {"a" [1 1 2 2]
              "b" ["a" "b" "c" "d"]}
             (api/dataset)
             (api/group-by "a"))]
  (seq (ds :data))) ;; seq is not necessary but Markdown treats `:data` as command here
```

```{clojure results="asis"}
(-> {"a" [1 1 2 2]
     "b" ["a" "b" "c" "d"]}
    (api/dataset)
    (api/group-by "a")
    (api/groups->seq))
```

---

Groups as map

```{clojure results="asis"}
(-> {"a" [1 1 2 2]
     "b" ["a" "b" "c" "d"]}
    (api/dataset)
    (api/group-by "a")
    (api/groups->map))
```

---

Grouping by more than one column. You can see that group names are maps. When ungrouping is done these maps are used to restore column names.

```{clojure results="asis"}
(api/group-by DS [:V1 :V3] {:result-type :as-seq})
```

---

Grouping can be done by providing just row indexes. This way you can assign the same row to more than one group.

```{clojure results="asis"}
(api/group-by DS {"group-a" [1 2 1 2]
                  "group-b" [5 5 5 1]} {:result-type :as-seq})
```

---

You can group by a result of gruping function which gets row as map and should return group name. When map is used as a group name, ungrouping restore original column names.

```{clojure results="asis"}
(api/group-by DS (fn [row] (* (:V1 row)
                             (:V3 row))) {:result-type :as-seq})
```

---

You can use any predicate on column to split dataset into two groups.

```{clojure results="asis"}
(api/group-by DS (comp #(< % 1.0) :V3) {:result-type :as-seq})
```

---

`juxt` is also helpful

```{clojure results="asis"}
(api/group-by DS (juxt :V1 :V3) {:result-type :as-seq})
```

--- 

`tech.ml.dataset` provides an option to limit columns which are passed to grouping functions. It's done for performance purposes.

```{clojure results="asis"}
(api/group-by DS identity {:result-type :as-seq
                           :limit-columns [:V1]})
```

#### Ungrouping

Ungrouping simply concats all the groups into the dataset. Following options are possible

* `:order?` - order groups according to the group name ascending order. Default: `false`
* `:add-group-as-column` - should group name become a column? If yes column is created with provided name (or `:$group-name` if argument is `true`). Default: `nil`.
* `:add-group-id-as-column` - should group id become a column? If yes column is created with provided name (or `:$group-id` if argument is `true`). Default: `nil`.
* `:dataset-name` - to name resulting dataset. Default: `nil` (_unnamed)

If group name is a map, it will be splitted into separate columns. Be sure that groups (subdatasets) doesn't contain the same columns already.

If group name is a vector, it will be splitted into separate columns. If you want to name them, set vector of target column names as `:add-group-as-column` argument.

After ungrouping, order of the rows is kept within the groups but groups are ordered according to the internal storage.

---

Grouping and ungrouping.

```{clojure results="asis"}
(-> DS
    (api/group-by :V3)
    (api/ungroup))
```

---

Groups sorted by group name and named.

```{clojure results="asis"}
(-> DS
    (api/group-by :V3)
    (api/ungroup {:order? true
                  :dataset-name "Ordered by V3"}))
```

---

Let's add group name and id as additional columns

```{clojure results="asis"}
(-> DS
    (api/group-by (comp #(< % 4) :V2))
    (api/ungroup {:add-group-as-column true
                  :add-group-id-as-column true}))
```

---

Let's assign different column names

```{clojure results="asis"}
(-> DS
    (api/group-by (comp #(< % 4) :V2))
    (api/ungroup {:add-group-as-column "Is V2 less than 4?"
                  :add-group-id-as-column "group id"}))
```

---

If we group by map, we can automatically create new columns out of group names.

```{clojure results="asis"}
(-> DS
    (api/group-by (fn [row] {"V1 and V3 multiplied" (* (:V1 row)
                                                      (:V3 row))
                            "V4 as string" (str (:V4 row))}))
    (api/ungroup {:add-group-as-column true}))
```

---

We can add group names without separation

```{clojure results="asis"}
(-> DS
    (api/group-by (fn [row] {"V1 and V3 multiplied" (* (:V1 row)
                                                      (:V3 row))
                            "V4 as string" (str (:V4 row))}))
    (api/ungroup {:add-group-as-column "just map"
                  :separate? false}))
```

---

The same applies to group names as sequences

```{clojure results="asis"}
(-> DS
    (api/group-by (juxt :V1 :V3))
    (api/ungroup {:add-group-as-column "abc"}))
```

---

Let's provide column names

```{clojure results="asis"}
(-> DS
    (api/group-by (juxt :V1 :V3))
    (api/ungroup {:add-group-as-column ["v1" "v3"]}))
```

---

Also we can supress separation

```{clojure results="asis"}
(-> DS
    (api/group-by (juxt :V1 :V3))
    (api/ungroup {:separate? false
                  :add-group-as-column true}))
```



#### Other functions

### Columns

### Rows

### Aggregate

### Order

### Unique

### Missing

### Join/Split Columns

### Fold/Unroll Rows

### Reshape

### Join/Concat
